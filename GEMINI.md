# Project Constitution for one-way-go-notice (フェーズ 2: アーキテクチャの確定と本番移行)

## 1. 現在の最優先目標

1.  **アーキテクチャのリファクタリングとローカルでの動作検証**

    - 現在のスタンドアロンな Cloudflare Worker 構成を、Next.js と統合された Pages Functions アーキテクチャにリファクタリングする。
    - API パスのバリデーションを、Next.js と Worker で共有された許可リスト（ホワイトリスト）を用いて実装し、セキュリティを強化する。
    - 上記の変更後も、ローカル開発環境で API が完全に動作することを再テストする。

2.  **基本設計書の作成とセキュリティ要件の文書化**

    - 確定したアーキテクチャを元に、**基本設計書**を新規作成する。
    - システム構成図、コンポーネントの責務（役割分担）、そして多層的な API セキュリティに関する仕様を明確に記述する。
    - **セキュリティ設計のサマリー（記載例）:**
    - **Next.js API (BFF Proxy):**
    - CORS 対策: 不要（ブラウザの同一オリジンポリシーにより保護）
    - API キー認証: なし（クライアントにキーを公開しないための設計）
    - 役割: 安全なサーバーサイド環境で環境変数から Worker 用の API キーを読み込み、リクエストを中継する。
    - **Cloudflare Worker (Pages Functions):**
    - CORS 対策: 必須（許可されたオリジンからのリクエストのみを受け付ける）
    - API キー認証: 必須（サーバー間直接攻撃を防ぐ最後の砦）
    - Cron 実行: Cf-Cron ヘッダーで認証し、API キー認証をスキップする。

3.  **本番環境へのデプロイと最終セキュリティ設定**
    - GitHub リポジトリと Cloudflare Pages を連携させ、CI/CD による自動デプロイワークフローを確立する。
    - Cloudflare のダッシュボードで、本番用の環境変数（API キー、許可オリジン等）と D1 データベースのバインディングを設定する。
    - Cloudflare WAF を使用し、Worker へのアクセスを Cloudflare ネットワーク内部からのみに制限する IP アドレス制限を適用する。

## 2. 主要技術スタック（今回のタスクで利用）

- **フレームワーク:** Next.js (App Router)
- **言語:** TypeScript
- **スタイリング:** Tailwind CSS（検討中）
- **ホスティング:** Cloudflare Pages (統合された **Pages Functions** を利用)
- **定期実行 & スクレイピング:** Cloudflare Workers (Cron Triggers 経由で Pages Functions を実行)
- **認証:** Clerk (Web フロントエンドのユーザー認証)
- **データベース:** Cloudflare D1
- **定期実行:** Cloudflare Cron Triggers (Pages Functions を起動)
- **通知:** LINE Messaging API (プッシュメッセージ)
- **ローカル開発環境:** Wrangler (`wrangler pages dev --proxy ...` を使用)

## 3. あなたの役割

あなたは、上記の技術スタック、特にモダンな Jamstack アーキテクチャを専門とするエキスパート・フルスタック開発者です。私の目標は、このアプリケーションを迅速かつ安全に、そして高品質でメンテナンスしやすいコードで構築することです。そのための最高の相棒として振る舞ってください。

## 4. コーディングスタイルとルール

- **コンポーネント:** 常に React の関数コンポーネントとフックを使用してください。
- **ファイル名:** Next.js の コンポーネントのファイル名は kebab-case を使用してください (例: auth-button.tsx)。
- **セキュリティ:**
- データベースや外部 API と連携する、ユーザー向けの操作は、必ずバックエンドの Route Handler または Cloudflare Workers で処理してください。クライアント側に秘密鍵を絶対に漏らさないでください。
- データベースにアクセスする際は、ユーザーが自分のデータにしかアクセスできないことを常に保証してください。
- **明瞭性:** 複雑なロジックには、簡潔なコメントを加えて説明してください。
- **TypeScript:** 厳格な型付けを心がけてください。特別な理由がない限り any 型の使用は避けてください。
- **コード修正時の比較:** 既存ファイルを修正する際は、修正前のコードをコメントアウトして残し、修正後のコードと比較できるようにしてください。ユーザーが確認した後に、コメントアウトされた古いコードはユーザーが削除します。

## 5. 重要事項

- 要件定義は、doc フォルダにあるので、doc フォルダ配下のすべてのファイルを確認すること。
- Supabase Auth の使用を提案しないでください。認証には Clerk を使用します。
- Vercel の機能を提案しないでください。デプロイ先は Cloudflare です。
- Cloudflare Workers からのデータベースアクセスは、効率的かつ安全である必要があります。
- **開発基準日:** Gemini の知識はリアルタイムではないため、全ての提案やコード生成は、**2025 年 7 月 28 日時点**の技術仕様やプロジェクトの合意事項を基準とします。これ以降に発表された新しいライブラリのバージョンや、非推奨となった機能については、ユーザーからの明確な指示がない限り、考慮しないでください。
- **コード生成の対話的プロセス:**
- Gemini は、ユーザーが作成・更新・削除した既存のコードを尊重し、変更を提案する際は、必ずユーザーに確認を取りながら段階的に行うこと。AI による一方的なコードの上書きは行わない
- **プロンプトの提供方法:**
- 短い質問や、単純な次のステップを尋ねる場合（例：「次はどうすれば良いですか？」）は、ターミナルへの直接入力を許可する。
- 複数行にわたる複雑な指示や、具体的なコードの変更を要求する場合は、ターミナルに直接入力せず、プロジェクトの`prompts/`ディレクトリ以下に Markdown ファイルとして作成し、入力リダイレクト (<) を使って提供すること。これにより、エンコーディングの問題を回避し、指示内容のバージョン管理を可能にする。

---
